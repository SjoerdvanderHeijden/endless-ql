/*
 * generated by Xtext 2.12.0
 */
package org.uva.sc.pc.ql.validation

import java.util.List
import org.eclipse.xtext.validation.Check
import org.uva.sc.pc.ql.qLang.And
import org.uva.sc.pc.ql.qLang.Block
import org.uva.sc.pc.ql.qLang.Comparison
import org.uva.sc.pc.ql.qLang.Equality
import org.uva.sc.pc.ql.qLang.MulOrDiv
import org.uva.sc.pc.ql.qLang.Not
import org.uva.sc.pc.ql.qLang.Or
import org.uva.sc.pc.ql.qLang.PlusOrMinus
import org.uva.sc.pc.ql.qLang.QLangPackage
import org.uva.sc.pc.ql.qLang.QuestionRef
import org.uva.sc.pc.ql.qLang.QuestionType
import org.uva.sc.pc.ql.qLang.TypeBool
import org.uva.sc.pc.ql.qLang.TypeDate
import org.uva.sc.pc.ql.qLang.TypeDecimal
import org.uva.sc.pc.ql.qLang.TypeInteger
import org.uva.sc.pc.ql.qLang.TypeMoney
import org.uva.sc.pc.ql.qLang.TypeString
import org.uva.sc.pc.ql.qLang.util.TypeUtil

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class QLangExpressionValidator extends AbstractQLangValidator {

	public static val INVALID_EXPRESSION = 'invalidExpression'

	public static val ALLOWED_OPS_AND_TYPES = #{
		TypeBool -> #[TypeUtil.OP_AND, TypeUtil.OP_OR],
		TypeString -> #[TypeUtil.OP_PLUS],
		TypeInteger ->
			#[TypeUtil.OP_SMALLER_THAN, TypeUtil.OP_SMALLER_THAN_EQUALS, TypeUtil.OP_GREATER_THAN,
				TypeUtil.OP_GREATER_THAN_EUQALS, TypeUtil.OP_PLUS, TypeUtil.OP_MINUS, TypeUtil.OP_MUL, TypeUtil.OP_DIV],
		TypeDecimal ->
			#[TypeUtil.OP_SMALLER_THAN, TypeUtil.OP_SMALLER_THAN_EQUALS, TypeUtil.OP_GREATER_THAN,
				TypeUtil.OP_GREATER_THAN_EUQALS, TypeUtil.OP_PLUS, TypeUtil.OP_MINUS, TypeUtil.OP_MUL, TypeUtil.OP_DIV],
		TypeDate -> #[],
		TypeMoney ->
			#[TypeUtil.OP_SMALLER_THAN, TypeUtil.OP_SMALLER_THAN_EQUALS, TypeUtil.OP_GREATER_THAN,
				TypeUtil.OP_GREATER_THAN_EUQALS, TypeUtil.OP_PLUS, TypeUtil.OP_MINUS, TypeUtil.OP_MUL, TypeUtil.OP_DIV]
	}

	def getAllowedOpsForType(QuestionType type) {
		switch (type) {
			TypeBool: ALLOWED_OPS_AND_TYPES.get(TypeBool) as List<String>
			TypeString: ALLOWED_OPS_AND_TYPES.get(TypeString) as List<String>
			TypeInteger: ALLOWED_OPS_AND_TYPES.get(TypeInteger) as List<String>
			TypeDecimal: ALLOWED_OPS_AND_TYPES.get(TypeDecimal) as List<String>
			TypeDate: ALLOWED_OPS_AND_TYPES.get(TypeDate) as List<String>
			TypeMoney: ALLOWED_OPS_AND_TYPES.get(TypeMoney) as List<String>
		}
	}

	@Check
	def checkVariableRef(QuestionRef exp) {
		var questionType = exp.question.type
		var List<String> allowedOps = getAllowedOpsForType(questionType)
		var parent = exp.eContainer
		var error = false;
		switch (parent) {
			Or:
				error = !allowedOps.contains(parent.op)
			And:
				error = !allowedOps.contains(parent.op)
			Equality:
				error = !allowedOps.contains(parent.op)
			Comparison:
				error = !allowedOps.contains(parent.op)
			PlusOrMinus:
				error = !allowedOps.contains(parent.op)
			MulOrDiv:
				error = !allowedOps.contains(parent.op)
			Not:
				error = !allowedOps.contains(TypeUtil.OP_NOT)
			Block: {
			}
		}
		if (error)
			error('operation is undefined for type ' + questionType, QLangPackage.Literals.QUESTION_REF__QUESTION,
				INVALID_EXPRESSION)
	}

}
