/*
 * generated by Xtext 2.12.0
 */
package org.uva.sc.pc.ql.validation

import org.eclipse.xtext.validation.Check
import org.uva.sc.pc.ql.qLang.Block
import org.uva.sc.pc.ql.qLang.Expression
import org.uva.sc.pc.ql.qLang.ExpressionAnd
import org.uva.sc.pc.ql.qLang.ExpressionComparison
import org.uva.sc.pc.ql.qLang.ExpressionEquality
import org.uva.sc.pc.ql.qLang.ExpressionMulOrDiv
import org.uva.sc.pc.ql.qLang.ExpressionNot
import org.uva.sc.pc.ql.qLang.ExpressionOr
import org.uva.sc.pc.ql.qLang.ExpressionPlusOrMinus
import org.uva.sc.pc.ql.qLang.ExpressionQuestionRef
import org.uva.sc.pc.ql.qLang.QLangPackage
import org.uva.sc.pc.ql.qLang.Question
import org.uva.sc.pc.ql.qLang.util.TypeUtil

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class QLangExpressionValidator extends AbstractQLangValidator {

	public static val TYPE_NOT_ALLOWED = 'typeNotAllowed'
	public static val TYPE_NOT_ALLOWED_MESSAGE = "this type is not allowed for the specified operation"

	public static val TYPE_NOT_SAME = 'typeNotSame'
	public static val TYPE_NOT_SAME_MESSAGE = "The provided types for this operation have to be the same"

	public static val BLOCK_INVALID_EXPRESSION = 'blockInvalidExpression'
	public static val BLOCK_INVALID_EXPRESSION_MESSAGE = "Not a boolean expression"

	public static val TYPE_NOT_EXPECTED = 'typeNotExpected'
	public static val TYPE_NOT_EXPECTED_MESSAGE = "The resulting type does not match the expected type"

	def String computeType(Expression exp) {
		switch exp {
			ExpressionOr:
				TypeUtil.TYPE_BOOLEAN
			ExpressionAnd:
				TypeUtil.TYPE_BOOLEAN
			ExpressionEquality:
				TypeUtil.TYPE_BOOLEAN
			ExpressionComparison:
				TypeUtil.TYPE_BOOLEAN
			ExpressionPlusOrMinus: {
				computeType(exp.left)
			}
			ExpressionMulOrDiv: {
				computeType(exp.left)
			}
			ExpressionNot:
				TypeUtil.TYPE_BOOLEAN
			ExpressionQuestionRef:
				TypeUtil.getTypeForQuestionType(exp.question.type)
		}
	}

	@Check
	def checkExpressionOr(ExpressionOr exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_OR__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_OR__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_OR__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionAnd(ExpressionAnd exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_AND__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_AND__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_AND__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionEquality(ExpressionEquality exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_EQUALITY__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_EQUALITY__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_EQUALITY__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionComparison(ExpressionComparison exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_COMPARISON__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_COMPARISON__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_COMPARISON__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionPlusOrMinus(ExpressionPlusOrMinus exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_PLUS_OR_MINUS__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_PLUS_OR_MINUS__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_PLUS_OR_MINUS__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionMulOrDiv(ExpressionMulOrDiv exp) {

		var leftType = computeType(exp.left)
		var rightType = computeType(exp.right)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(exp.op)
		if (!allowedTypes.contains(leftType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_MUL_OR_DIV__LEFT, TYPE_NOT_ALLOWED)

		if (!allowedTypes.contains(rightType))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_MUL_OR_DIV__RIGHT, TYPE_NOT_ALLOWED)

		if (leftType != rightType)
			error(TYPE_NOT_SAME_MESSAGE, QLangPackage.Literals.EXPRESSION_MUL_OR_DIV__RIGHT, TYPE_NOT_SAME)

	}

	@Check
	def checkExpressionNot(ExpressionNot exp) {

		var type = computeType(exp.expression)

		var allowedTypes = TypeUtil.allowedTypesForOps.get(TypeUtil.OP_NOT)
		if (!allowedTypes.contains(type))
			error(TYPE_NOT_ALLOWED_MESSAGE, QLangPackage.Literals.EXPRESSION_NOT__EXPRESSION, TYPE_NOT_ALLOWED)

	}

	@Check
	def checkBlockExpression(Block block) {

		if (computeType(block.expression) != TypeUtil.TYPE_BOOLEAN) {
			error(BLOCK_INVALID_EXPRESSION_MESSAGE, QLangPackage.Literals.BLOCK__EXPRESSION, BLOCK_INVALID_EXPRESSION)
		}

	}

	@Check
	def checkComputedQuestion(Question question) {

		if (question.expression !== null) {
			var expectedType = TypeUtil.getTypeForQuestionType(question.type)
			var computedType = computeType(question.expression)
			if (expectedType != computedType)
				error(TYPE_NOT_EXPECTED_MESSAGE, QLangPackage.Literals.QUESTION__EXPRESSION, TYPE_NOT_EXPECTED)
		}

	}

}
