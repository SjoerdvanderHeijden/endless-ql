/*
 * Grammar for the Questionnaire Language
 *
 */

{
    // Mapping of operators to their TypeScript class
    let operationMapping = {
        //"!"  : Node.Negation,
        "&&" : Nodes.And,
        "||" : Nodes.Or,
        "<=" : Nodes.SmallerThanOrEqual,
        ">=" : Nodes.LargerThanOrEqual,
        "!=" : Nodes.NotEqual,
        "==" : Nodes.Equals,
        "<"  : Nodes.SmallerThan,
        ">"  : Nodes.LargerThan,
        "+"  : Nodes.Addition,
        "-"  : Nodes.Subtraction,
        "*"  : Nodes.Multiplication,
        "/"  : Nodes.Division
    }

    // Mapping of types to their TypeScript class
    let typeMapping = {
        "boolean" : FieldType.Boolean,
        "date" : FieldType.Date,
        "money" : FieldType.Money,
        "integer" : FieldType.Integer,
        "decimal" : FieldType.Decimal,
        "text" : FieldType.Text,
    }

    function makeOperationNode(left, head) {
        const Operation = operationMapping[head[1]];
        return new Operation(left, head[3]);
    }

    // Create correct expression hierarchy
    function buildExpression(head, tail) {
        let expressionNode = tail.reduce(makeOperationNode, head);
        return addLocation(expressionNode);
    }

  // Add location to every node
  function addLocation(node){
    node.setLocation(location());
    return node;
  }
}

Root = __ forms:Form+ __ { return forms }

UnaryOps
  = "!"

BoolOps
  = "&&"
  / "||"

CompOps
  = "<="
  / ">="
  / "!="
  / "=="
  / "<"
  / ">"

AddOps
  = "+"
  / "-"

MultOps
  = "*"
  / "/"

AritmicOps
  = MultOps
  / AddOps

Types
  = "boolean"
  / "money"
  / "date"
  / "integer"
  / "decimal"
  / "text"

BlockBody
  = Field
  / IfCondition

FieldType
 = fieldType:Types {
    return typeMapping[fieldType];
}

Field
 = label:StringLiteral __ identifier:Identifier _ ":" _ type:FieldType __ expression:("=" __ Expression)? __ {
    var name = identifier.identifier;
    if (expression)
        return new Nodes.ComputedField(name, label.value, type, expression[2]);
    let fieldNode = new Nodes.Question(name, label.value, type);
    return addLocation(fieldNode);
}

Block
 = "{" __ body:(BlockBody)+ __ "}" __ {
     return body;
}

Form
 = FormToken _ identifier:Identifier _ block:Block {
     let formNode = new Nodes.FormNode(identifier.identifier, block);
     return addLocation(formNode);
}

IfCondition
 = IfToken _ predicate:ExpressionWithBrackets _ block:Block _ elseBlock:ElseStatement? __ {
     let IfConditionNode = new Nodes.IfCondition(predicate, block, elseBlock);
     return addLocation(IfConditionNode);
}

ElseStatement
 = ElseToken _ block:Block __ {
    return block;
}

Expression
 = expression:BooleanExpression {
    return expression;
}

ExpressionWithBrackets
 = "("_ expr:Expression _ ")" {
    return expr;
}

BooleanExpression
  = head:ComparisonExpression _ tail:(_ BoolOps _ ComparisonExpression)+ _ {
    let boolExpressionNode = buildExpression(head, tail);
    return addLocation(boolExpressionNode);
  }
  / ComparisonExpression

ComparisonExpression
  = head:AdditiveExpression _ tail:(_ CompOps _ AdditiveExpression)+ _ {
    let comparisonExpressionNode = buildExpression(head, tail);
    return addLocation(comparisonExpressionNode);
  }
  / AdditiveExpression

AdditiveExpression
  = head:MultiplicativeExpression _ tail:(_ AddOps _ MultiplicativeExpression)+ _{
    let additiveExpressionNode = buildExpression(head, tail);
    return addLocation(additiveExpressionNode);
  }
  / MultiplicativeExpression

MultiplicativeExpression
  = head:Primary _ tail:(_ MultOps _ Primary)+ _{
    let multiplicativeExpressionNode = buildExpression(head, tail);
    return addLocation(multiplicativeExpressionNode);
  }
  / Primary

Primary
  = Value
  / ExpressionWithBrackets
  / UnaryExpression

UnaryExpression
 = UnaryOps value:Primary _ {
    let unaryExpressionNode = new Nodes.Negation(value);
    return addLocation(unaryExpressionNode);
}

Identifier
  = !Keywords Alphabet AlphabetOrNumbers+ {
    let identifierNode = new Nodes.VariableIdentifier(text());
    return addLocation(identifierNode);
}

BooleanLiteral
 = BooleanToken {
    let booleanLiteralNode = new Nodes.BooleanLiteral(text() == "true");
    return addLocation(booleanLiteralNode);
}

NumberLiteral
 = minus:[-]? digits:([0-9\.]+) {
    let amount = digits.join("");
    if (minus)
        amount = minus.concat(amount);
    let numberLiteralNode = Nodes.NumberLiteral.fromString(amount);
    return addLocation(numberLiteralNode);
}

DateLiteral
 = [0-9][0-9] dateSeparator [0-9][0-9] dateSeparator [0-9][0-9][0-9][0-9]{
    let dateLiteralNode = Nodes.DateLiteral.fromString(text());
    return addLocation(dateLiteralNode);
}

dateSeparator
 = [\.]

// String Literal, Currently only support double quoted Strings
StringLiteral "String literal"
 = '"' chars:DoubleQuotedStringCharacters* '"'{
    let stringLiteralNode = new Nodes.StringLiteral(chars.join(''));
    return addLocation(stringLiteralNode);
}

DoubleQuotedStringCharacters
  = !('"' / "\\") char:. { return char; }
  / "\\" sequence:EscapeSequence { return sequence; }

EscapeSequence
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b";   }
  / "f"  { return "\f";   }
  / "n"  { return "\n";   }
  / "r"  { return "\r";   }
  / "t"  { return "\t";   }
  / "v"  { return "\x0B"; }

Value
 = Identifier
 / DateLiteral
 / NumberLiteral
 / StringLiteral
 / BooleanLiteral

BooleanToken
 = BooleanTrue !Alphabet
 / BooleanFalse !Alphabet

BooleanTrue = "true"
BooleanFalse = "false"

IfToken = "if" !Alphabet
ElseToken = "else" !Alphabet
FormToken = "form" !Alphabet

Keywords = BooleanToken


Alphabet
  = [a-zA-Z]

Numbers
  = [0-9]

AlphabetOrNumbers
  = Alphabet
  / Numbers

SourceCharacter = .

WhiteSpace "Whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"

_ = (WhiteSpace / MultiLineCommentNoLineTerminator)*
__ = (WhiteSpace / LineTerminatorSequence / Comment)*

LineTerminatorSequence "End of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"

LineTerminator
    = [\n\r\u2028\u2029]

Comment "Comment"
  = MultiLineComment
  / SingleLineComment

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"