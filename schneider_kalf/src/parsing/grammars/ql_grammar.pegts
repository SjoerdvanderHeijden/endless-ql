/*
 * Grammar for the Questionnaire Language
 *
 */

{
  // Mapping of operators to their TypeScript class
  let operationMapping = {
    "&&" : Nodes.And,
    "||" : Nodes.Or,
    "<=" : Nodes.SmallerThanOrEqual,
    ">=" : Nodes.LargerThanOrEqual,
    "!=" : Nodes.NotEqual,
    "==" : Nodes.Equals,
    "<"  : Nodes.SmallerThan,
    ">"  : Nodes.LargerThan,
    "+"  : Nodes.Addition,
    "-"  : Nodes.Subtraction,
    "*"  : Nodes.Multiplication,
    "/"  : Nodes.Division
  }

  // Mapping of types to their TypeScript class
  let typeMapping = {
    "boolean" : FieldType.Boolean,
    "date" : FieldType.Date,
    "money" : FieldType.Money,
    "integer" : FieldType.Integer,
    "decimal" : FieldType.Decimal,
    "text" : FieldType.Text,
  }

  function makeOperationNode(left, head) {
    const Operation = operationMapping[head[1]];
    return new Operation(left, head[3]);
  }

  function makeExpressionNode(head, tail) {
    let expressionNode = tail.reduce(makeOperationNode, head);
    return expressionNode.setLocation(location());
  }
}

Root
  = __ forms:Form+ __ {
    return forms
  }

UnaryOps
  = "!"

BoolOps
  = "&&"
  / "||"

CompOps
  = "<="
  / ">="
  / "!="
  / "=="
  / "<"
  / ">"

AddOps
  = "+"
  / "-"

MultOps
  = "*"
  / "/"

AritmicOps
  = MultOps
  / AddOps

Types
  = "boolean"
  / "money"
  / "date"
  / "integer"
  / "decimal"
  / "text"

Form
  = FormToken _ identifier:Identifier __ block:Block {
   let formNode = new Nodes.FormNode(identifier, block);
   return formNode.setLocation(location());
}

Block
  = "{" __ body:(Field / IfCondition)+ __ "}" __ {
    return body;
}

Field
  = label:StringLiteral __ identifier:Identifier _ ":" _ type:FieldType __ expression:("=" __ Expression)? __ {
    if (expression) {
      let computedFieldNode = new Nodes.ComputedField(identifier, label.value, type, expression[2]);
      return computedFieldNode.setLocation(location());
    }
    let fieldNode = new Nodes.Question(identifier, label.value, type);
    return fieldNode.setLocation(location());
}

FieldType
  = fieldType:Types {
    return typeMapping[fieldType];
}

IfCondition
  = IfToken _ predicate:ExpressionWithBrackets __ thenBlock:Block __ elseBlock:Else? __ {
    let IfConditionNode = new Nodes.IfCondition(predicate, thenBlock, elseBlock);
    return IfConditionNode.setLocation(location());
}

Else
  = ElseToken _ block:Block __ {
    return block;
}

Expression
  = expression:BooleanExpression {
    return expression;
}

ExpressionWithBrackets
  = "("_ expression:Expression _ ")" {
    return expression;
}

BooleanExpression
  = head:ComparisonExpression _ tail:(_ BoolOps _ ComparisonExpression)+ _ {
    return makeExpressionNode(head, tail).setLocation(location());
  }
  / ComparisonExpression

ComparisonExpression
  = head:AdditiveExpression _ tail:(_ CompOps _ AdditiveExpression)+ _ {
    return makeExpressionNode(head, tail).setLocation(location());
  }
  / AdditiveExpression

AdditiveExpression
  = head:MultiplicativeExpression _ tail:(_ AddOps _ MultiplicativeExpression)+ _{
    return makeExpressionNode(head, tail).setLocation(location());
  }
  / MultiplicativeExpression

MultiplicativeExpression
  = head:ExpressionElement _ tail:(_ MultOps _ ExpressionElement)+ _{
    return makeExpressionNode(head, tail).setLocation(location());
  }
  / ExpressionElement

ExpressionElement
  = Value
  / ExpressionWithBrackets
  / UnaryExpression

UnaryExpression
  = UnaryOps value:ExpressionElement _ {
    let unaryExpressionNode = new Nodes.Negation(value);
    return unaryExpressionNode.setLocation(location());
}

ExpressionVariableIdentifier
  = Identifier {
    let identifierNode = new Nodes.VariableIdentifier(text());
    return identifierNode.setLocation(location());
}

Identifier
  = !Keywords Alphabet AlphabetOrNumbers+ {
    return text();
}

BooleanLiteral
  = BooleanToken {
    let booleanLiteralNode = new Nodes.BooleanLiteral(text() === "true");
    return booleanLiteralNode.setLocation(location());
}

NumberLiteral
  = [-]?[0-9\.]+ {
    let numberLiteralNode = Nodes.NumberLiteral.fromString(text());
    return numberLiteralNode.setLocation(location());
}

DateLiteral
  = [0-9][0-9] dateSeparator [0-9][0-9] dateSeparator [0-9][0-9][0-9][0-9]{
    let dateLiteralNode = Nodes.DateLiteral.fromString(text());
    return dateLiteralNode.setLocation(location());
}

dateSeparator
  = [\.]

// String Literal, only support double quoted Strings
StringLiteral "String literal"
  = '"' chars:DoubleQuotedStringCharacters* '"' {
    let stringLiteralNode = new Nodes.StringLiteral(chars.join(''));
    return stringLiteralNode.setLocation(location());
}

DoubleQuotedStringCharacters
  = !('"' / "\\") char:. { return char; }
  / "\\" sequence:EscapeSequence { return sequence; }

EscapeSequence
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b";   }
  / "f"  { return "\f";   }
  / "n"  { return "\n";   }
  / "r"  { return "\r";   }
  / "t"  { return "\t";   }
  / "v"  { return "\x0B"; }

Value
  = ExpressionVariableIdentifier
  / DateLiteral
  / NumberLiteral
  / StringLiteral
  / BooleanLiteral

BooleanToken
  = BooleanTrue !Alphabet
  / BooleanFalse !Alphabet

BooleanTrue = "true"
BooleanFalse = "false"

IfToken = "if" !Alphabet
ElseToken = "else" !Alphabet
FormToken = "form" !Alphabet

Keywords = BooleanToken

Alphabet
  = [a-zA-Z]

Numbers
  = [0-9]

AlphabetOrNumbers
  = Alphabet
  / Numbers

WhiteSpace "Whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"

_ = (WhiteSpace / MultiLineCommentNoLineTerminator)*
__ = (WhiteSpace / LineTerminatorSequence / Comment)*

LineTerminatorSequence "End of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"

LineTerminator
    = [\n\r\u2028\u2029]

Comment "Comment"
  = MultiLineComment
  / SingleLineComment

SingleLineComment
  = "//" (!LineTerminator .)*

MultiLineComment
  = "/*" (!"*/" .)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) .)* "*/"
