/*
 * Grammar for the Questionnaire Language
 *
 */

{
  // Dictionary of operators to their tsc definition
  let operations = {
              //"!"  : Node.Negation,
              "&&" : Nodes.And,
              "||" : Nodes.Or,
              "<=" : Nodes.SmallerThanOrEqual,
              ">=" : Nodes.LargerThanOrEqual,
              "!=" : Nodes.NotEqual,
              "==" : Nodes.Equals,
              "<"  : Nodes.SmallerThan,
              ">"  : Nodes.LargerThan,
              "+"  : Nodes.Addition,
              "-"  : Nodes.Subtraction,
              "*"  : Nodes.Multiplication,
              "/"  : Nodes.Division
            }

    // Dictionary of types to their tsc definition
    let types = {
                  "boolean" : FieldType.Boolean,
                  "date" : FieldType.Date,
                  "money" : FieldType.Money,
                  "integer" : FieldType.Integer,
                  "float" : FieldType.Float,
                  "text" : FieldType.Text,
                }

  // Base template for nodes
  function base(type, rest){
    return (<any>Object).assign({
        type:type,
        //location:location(),
    },
    rest)
  }

  // Building an expression
  function buildExpression(head, tail) {
    return tail.reduce(function(left, curr) {
      const Operation = operations[curr[1]];
      return new Operation(left, curr[3]);
    }
    , head);
  }
}

// Start node
start = forms:form+ _ lb* { return forms }

// Unary operation
unaryOps = "!"

// Boolean operations
boolOps = "&&" / "||"

// Compartive operations
compOps = "<=" / ">=" / "!=" / "==" / "<" / ">"

// Addative operations
addOps = "+" / "-"

// Multiplicant operations
multOps = "*" / "/"

// All includede aritmic operations
aritmicOps = multOps / addOps

// Literal types  supported
literalTypes = "boolean" / "money" / "date" / "integer" / "float" / "text"

// Returns the tsc object of the literal
type
 = literalType:literalTypes {
    return types[literalType];
}

// Returns a tsc Field object
field
 = _ label:stringLiteral lb* id:identifier _ ":" _ type:fieldType lb* expr:("=" lb* expression)? lb*{
    var name = id.identifier;
    if (expr)
        return new Nodes.ComputedField(name, label.value, type, expr[2]);
    return new Nodes.Question(name, label.value, type);
}

// Returns a list of fields and/or if statements
block
 = "{" lb* e:(field / if)+ lb* "}" {
     return e;
}

// Returns a tsc FormNode object
form
 = _ "form" _ id:identifier _ block:block lb*{
     return new Nodes.FormNode(id.identifier, block)
}

// Returns a tsc IfCondition object
if
 = _ "if" _ predicate:expression _ block:block lb* {
     return new Nodes.IfCondition(predicate, block);
}

// Initiates an expression
expression
 = expr:boolExpr {
    return expr;
}

// BooleanExpression
boolExpr
  = _ head:compExpr _ tail:(_(boolOps)_ compExpr)+ _{
    return buildExpression(head, tail)
  }
  / compExpr

// ComparisonExpression
compExpr
  = _ head:additiveExpr _ tail:(_(compOps)_ additiveExpr)+ _{
    return buildExpression(head, tail)
  }
  / additiveExpr

// AdditiveExpression
additiveExpr
  = _ head:multiplicativeExpr _ tail:(_(addOps)_ multiplicativeExpr)+ _{
    return buildExpression(head, tail)
  }
  / multiplicativeExpr

// MultiplicativeExpression
multiplicativeExpr
  = _ head:primary _ tail:(_(multOps)_ primary)+ _{
    return buildExpression(head, tail)
  }
  / primary

primary
  = value
  / "("_ expr:boolExpr _ ")" { return expr; }
  / unaryExpr

// UnaryExpression
unaryExpr
 = _ op:unaryOps value:primary _ {
    return new Nodes.Negation(value)
}

// Identifier
identifier
 = !keywords alphabet {
    return new Nodes.VariableIdentifier(text());
}

// Boolean Literal
booleanLiteral
 = booleanToken {
    return new Nodes.BooleanLiteral(text() == "true")
}

// Alphabet characters
alphabet
 = [a-zA-Z]+

// Integer
numberLiteral
 = minus:[-]? digits:([0-9]+) {
    var amount = digits.join("");
    if (minus)
        amount = minus.concat(amount);
    return new Nodes.NumberLiteral(parseInt(amount))
}

// String Literal, Currently only support double quoted String
stringLiteral
 = '"' chars:doubleQuotedString* '"'{
    return new Nodes.StringLiteral(chars.join(''));
}

// Double quoted string pattern
doubleQuotedString
  = !('"' / "\\") char:. { return char; }
  / "\\" sequence:escapeSequence { return sequence; }

// Escape sequences for inside string
escapeSequence
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b";   }
  / "f"  { return "\f";   }
  / "n"  { return "\n";   }
  / "r"  { return "\r";   }
  / "t"  { return "\t";   }
  / "v"  { return "\x0B"; }

// Supported types
fieldType = "money" / "date" / "integer" / "boolean"

// Value
value = identifier / numberLiteral / stringLiteral / booleanLiteral

booleanToken = "true"  !alphabet
             / "false" !alphabet

keywords = booleanToken

// Single line comments
comment = "//" (![\n] .)*

// White spaces and new lines
ws = [ \t]
_ = (ws / comment)*
lb = [ \t\r\n] / comment