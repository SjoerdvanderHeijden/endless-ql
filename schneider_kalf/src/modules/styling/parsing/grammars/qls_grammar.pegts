/*
 * Grammar for Questionnaire Language Styling
 *
 */

{
    let widgetMapping = {
        "spinbox" : Nodes.SpinBoxWidgetAttribute,
        "text" : Nodes.TextWidgetAttribute,
        "slider" : Nodes.SliderWidgetAttribute,
        "dropdown" : Nodes.DropdownWidgetAttribute,
        "checkbox" : Nodes.CheckboxWidgetAttribute,
        "radio" : Nodes.RadioWidgetAttribute
    }

    let baseAttributeMapping = {
        "color" : Nodes.ColorAttribute,
        "width" : Nodes.WidthAttribute,
        "fontsize" : Nodes.FontSizeAttribute,
        "font" : Nodes.FontAttribute
    }
}

root
  = __ stylesheet:Stylesheet __ {
    return stylesheet
}

StylesheetToken = "stylesheet"
PageToken = "page"
SectionToken = "section"
QuestionToken = "question"
DefaultToken =  "default"
WidgetToken = "widget"
BooleanToken = "true" / "false"

Stylesheet
 = StylesheetToken _ id:Identifier __ "{" __ page:Page* __ "}" __{
    return new Nodes.Stylesheet( id, page);
}

Page
 = _ PageToken _ id:Identifier __ block:PageBlock __ {
    return new Nodes.Page( id, block );
}

PageBlock
 = "{" __ body:(Section / Default)+ __ "}" {
    return body;
}

Section
 = _ SectionToken _ name:StringLiteral __ block:SectionBlock {
    return new Nodes.Section( name, block );
}

SectionBlock
 = SectionBlockBrackets
 / SectionBlockNoBrackets

SectionBlockBrackets
 = _ "{" __ body:SectionBlockNoBrackets "}" __ {
    return body
}

SectionBlockNoBrackets
 = _ block:SectionAttribute+ __ {
    return block
}

SectionAttribute
 = _ attr:(Question / Section / Default) __ {
   return attr
}

Question
 = _ QuestionToken _ id:Identifier __ body:StyleBlock? __{
    body = body ? body : [];
    return new Nodes.QuestionStyle( id, body);
}

Default
 = _ DefaultToken _ type:Types __ args:StyleBlock {
    return new Nodes.DefaultStyle(type, args);
 }

StyleBlock
 = StyleBlockNoBrackets / StyleBlockBrackets

StyleBlockBrackets
 = "{" __ args:StyleAttribute+ __ "}" __ {
    return args;
}

StyleBlockNoBrackets
 = __ args:StyleAttribute+ __ {
    return args;
}

StyleAttribute
 = (Widget / Style)

Widget
 = _ WidgetToken _ id:Identifier options:WidgetOptions? __ {
    const WidgetConstructor = widgetMapping[id];
    return new WidgetConstructor(options);
}

WidgetOptions
 = "(" _ args:Arguments _ ")" __ {
    return args;
}

Arguments
  = head:StringLiteral rest:(_ "," _ r:Arguments { return r; })? {
    return rest != null ? [head].concat(rest) : [head];
}

Style
 = _ id:Identifier _ ":" _ args:StyleValues __{
    const BaseAttributeConstructor = baseAttributeMapping[id];
    return new BaseAttributeConstructor(args);
}

StyleValues
 = NumberLiteral / StringLiteral / ColorLiteral / BooleanLiteral

ColorLiteral
 = _ code:(["#"][0-9]+){
    return "#".concat(code[1].join(""))
}

Identifier
 = [a-zA-Z]+ {
    return text();
}

BooleanLiteral
  = BooleanToken {
    return text() == "true"
}

NumberLiteral
  = minus:[-]? digits:([0-9]+) {
    let amount = digits.join("");
    if (minus)
          amount = minus.concat(amount);
    return parseInt(digits.join(""), 10)
}

// String Literal, Currently only support double quoted Strings
StringLiteral
 = '"' chars:DoubleString* '"'{
    return chars.join('');
}

DoubleString
  = !('"' / "\\") char:. { return char; }
  / "\\" sequence:EscapeSequence { return sequence; }

EscapeSequence
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b";   }
  / "f"  { return "\f";   }
  / "n"  { return "\n";   }
  / "r"  { return "\r";   }
  / "t"  { return "\t";   }
  / "v"  { return "\x0B"; }

Types
  = "boolean"
  / "money"
  / "date"
  / "integer"
  / "float"
  / "text"

WhiteSpace
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"

_ = (WhiteSpace / MultiLineCommentNoLineTerminator)*
__ = (WhiteSpace / LineTerminatorSequence / Comment)*

LineTerminatorSequence
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"

SourceCharacter = .

Comment
  = MultiLineComment
  / SingleLineComment

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"

LineTerminator
    = [\n\r\u2028\u2029]