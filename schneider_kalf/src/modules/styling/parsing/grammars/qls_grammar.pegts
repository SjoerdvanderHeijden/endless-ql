/*
 * Grammar for Questionnaire Language Styling
 *
 */

{
    let widgetMapping = {
        "spinbox" : Nodes.SpinBoxWidgetAttribute,
        "text" : Nodes.TextWidgetAttribute,
        "slider" : Nodes.SliderWidgetAttribute,
        "dropdown" : Nodes.DropdownWidgetAttribute,
        "checkbox" : Nodes.CheckboxWidgetAttribute,
        "radio" : Nodes.RadioWidgetAttribute
    }

    let baseAttributeMapping = {
        "color" : Nodes.ColorAttribute,
        "width" : Nodes.WidthAttribute,
        "fontsize" : Nodes.FontSizeAttribute,
        "font" : Nodes.FontAttribute
    }
}

start = lb* stylesheet:stylesheet lb* { return stylesheet }

stylesheet
 = _ "stylesheet" _ id:identifier lb* "{" lb* page:page* lb* "}" lb*{
    return new Nodes.Stylesheet( id, page);
}

page
 = _ "page" _ id:identifier lb* block:pageBlock lb* {
    return new Nodes.Page( id, block );
}

pageBlock
 = "{" lb* body:(section / default)+ lb* "}" {
    return body;
}

section
 = _ "section" _ name:stringLiteral lb* block:sectionBlock {
    return new Nodes.Section( name, block );
}

sectionBlock
 = sectionBlockBrackets / sectionBlockNoBrackets

sectionBlockBrackets
 = _ "{" lb* body:sectionBlockNoBrackets "}" lb* {
    return body
}

sectionBlockNoBrackets
 = _ block:sectionAttribute+ lb* {
    return block
}

sectionAttribute
 = _ attr:(question / section / default) lb* {
   return attr
}

question
 = _ "question" _ id:identifier lb* body:styleBlock? lb*{
    body = body ? body : [];
    return new Nodes.QuestionStyle( id, body);
}

default
 = _ "default" _ type:type lb* args:styleBlock {
    return new Nodes.DefaultStyle(type, args);
 }

styleBlock
 = styleBlockNoBrackets / styleBlockBrackets

styleBlockBrackets
 = "{" lb* args:styleAttribute+ lb* "}" lb* {
    return args;
}

styleBlockNoBrackets
 = lb* args:styleAttribute+ lb* {
    return args;
}

styleAttribute
 = (widget / style)

widget
 = _ "widget" _ id:identifier options:widgetOptions? lb* {
    const WidgetConstructor = widgetMapping[id];
    return new WidgetConstructor(options);
}

widgetOptions
 = "(" _ args:arguments _ ")" lb* {
    return args;
}

arguments
  = head:stringLiteral rest:(_ "," _ r:arguments{ return r; })? {
    return rest != null ? [head].concat(rest) : [head];
}

style
 = _ id:identifier _ ":" _ args:styleValues lb*{
    const BaseAttributeConstructor = baseAttributeMapping[id];
    return new BaseAttributeConstructor(args);
}

styleValues
 = numberLiteral / stringLiteral / colorLiteral / booleanLiteral

colorLiteral
 = _ code:(["#"][0-9]+){
    return "#".concat(code[1].join(""))
}

identifier
 = chars:([a-zA-Z]+) {
    return chars.join("");
}

booleanLiteral
  = Literal:("true" / "false") {
    return Literal == "true"
}

numberLiteral
  = minus:[-]? digits:([0-9]+) {
    let amount = digits.join("");
    if (minus)
          amount = minus.concat(amount);
    return parseInt(digits.join(""), 10)
}

// String Literal, Currently only support double quoted Strings
stringLiteral
 = '"' chars:doubleString* '"'{
    return chars.join('');
}

doubleString
  = !('"' / "\\") char:. { return char; }
  / "\\" sequence:escapeSequence { return sequence; }

escapeSequence
  = "'"
  / '"'
  / "\\"
  / "b"  { return "\b";   }
  / "f"  { return "\f";   }
  / "n"  { return "\n";   }
  / "r"  { return "\r";   }
  / "t"  { return "\t";   }
  / "v"  { return "\x0B"; }

type = "boolean" / "money" / "date" / "integer" / "float" / "text"

comment = "//" (![\n] .)*

ws = [ \t]
_ = (ws / comment)*
lb = [ \t\r\n] / comment